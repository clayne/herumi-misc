import createModule = require('./bbs_c.js')
import getRandomValues from './getRandomValues'

const BBS_SECRETKEY_SIZE = 32
const BBS_PUBLICKEY_SIZE = 48*2*3
const BBS_SIGNATURE_SIZE = 32*3+32*2

/** @internal singleton of bbs WASM module generated by emscripten. */
export let mod: any

export const ptrToAsciiStr = (pos: number, n: number): string => {
  let s = ''
  for (let i = 0; i < n; i++) {
    s += String.fromCharCode(mod.HEAP8[pos + i])
  }
  return s
}

export const asciiStrToPtr = (pos: number, s: string): void => {
  for (let i = 0; i < s.length; i++) {
    mod.HEAP8[pos + i] = s.charCodeAt(i)
  }
}

export const toHex = (a: Uint8Array, start: number, n: number): string => {
  let s = ''
  for (let i = 0; i < n; i++) {
    s += ('0' + a[start + i].toString(16)).slice(-2)
  }
  return s
}

// Uint8Array to hex string
export const toHexStr = (a: Uint8Array): string => {
  return toHex(a, 0, a.length)
}

// hex string to Uint8Array
export const fromHexStr = (s: string): Uint8Array => {
  if ((s.length & 1) !== 0) throw new Error(`fromHexStr:length must be even (${s.length})`)
  const n = s.length / 2
  const a = new Uint8Array(n)
  for (let i = 0; i < n; i++) {
    a[i] = parseInt(s.slice(i * 2, i * 2 + 2), 16)
  }
  return a
}

export const free = (x: number): void => {
  mod._free(x)
}

type ToStrFunc = (x: number) => Uint8Array

const addWrappedMethods = (): void => {
  type StringReader = (pos: number, maxBufSize: number, x: number) => number
  const _wrapSerialize = (func: StringReader): ToStrFunc => {
    return (x: number) => {
      const stack = mod.stackSave()
      const maxBufSize = 4096
      const pos: number = mod.stackAlloc(maxBufSize)
      const n = func(pos, maxBufSize, x)
      if (n > 0) {
        let s = new Uint8Array(mod.HEAP8.subarray(pos, pos + n))
        mod.stackRestore(stack)
        return s
      } else {
        mod.stackRestore(stack)
        throw new Error(`err gen_str:${x}`)
      }
    }
  }

  type StringWriter = (pos: number, maxBufSize: number, x: number) => number
  const _wrapDeserialize = (func: StringWriter) => {
    return (x: number, buf: Uint8Array) => {
      const stack = mod.stackSave()
      const pos = mod.stackAlloc(buf.length)
      mod.HEAP8.set(buf, pos)
      const r = func(x, pos, buf.length)
      mod.stackRestore(stack)
      if (r === 0 || r !== buf.length) throw new Error(`err _wrapDeserialize: ${r} != ${buf.length}`)
    }
  }

  /*
    argNum : n
    func(x0, ..., x_(n-1), buf)
    => func(x0, ..., x_(n-1), pos, buf.length)
  */
  const _wrapInput = (func: Function, argNum: number) => {
    return function (...args: any[]) {
      const buf = args[argNum]
      const typeStr = Object.prototype.toString.apply(buf)
      if (!['[object String]', '[object Uint8Array]', '[object Array]'].includes(typeStr)) {
        throw new Error(`err bad type:"${typeStr}". Use String or Uint8Array.`)
      }
      const stack = mod.stackSave()
      const pos = mod.stackAlloc(buf.length)
      if (typeStr === '[object String]') {
        asciiStrToPtr(pos, buf)
      } else {
        mod.HEAP8.set(buf, pos)
      }
      const r: number = func(...args.slice(0, argNum), pos, buf.length)
      mod.stackRestore(stack)
      if (r !== 0) throw new Error('err _wrapInput')
    }
  }


  mod.g_his = []
  mod.g_ptr = {}
  mod.g_total = 0
  /*
    she libray always uses (malloc,free) in nested pairs.
  */
  mod._mallocDebug = (size: number): number => {
    const p = mod._mallocOrg(size + 4)
    mod.HEAP8[p + size] = 0x12
    mod.HEAP8[p + size + 1] = 0x34
    mod.HEAP8[p + size + 2] = 0x56
    mod.HEAP8[p + size + 3] = 0x78
    mod.g_his.push([p, size])
    mod.g_ptr[p] = size
    mod.g_total += size
    return p
  }
  mod._freeDebug = (pos: number): void => {
    const ps = mod.g_his.pop()
    const p = ps[0]
    const size = ps[1]
    if (pos !== p) {
      console.log(`pos=${pos} oldPos=${p}`)
    }
    const v = mod.HEAP8[p + size] + (mod.HEAP8[p + size + 1] << 8) + (mod.HEAP8[p + size + 2] << 16) + (mod.HEAP8[p + size + 3] << 24)
    if (v !== 0x78563412) {
      console.log(`ERR=${p} v=${v.toString(16)}`)
    }
    mod._freeOrg(pos)
    const s = mod.g_ptr[pos]
    if (s === 0) {
      console.log(`ERR ${pos}`)
    } else {
      delete mod.g_ptr[pos]
      mod.g_total -= s
    }
  }
  mod._mallocOrg = mod._malloc
  mod._freeOrg = mod._free
  mod.debug = false
  if (mod.debug) {
    mod._malloc = mod._mallocDebug
    mod._free = mod._freeDebug
  }
  mod.mclBnFr_setLittleEndianMod = _wrapInput(mod._mclBnFr_setLittleEndianMod, 1)

  mod.bbsDeserializeSecretKey = _wrapDeserialize(mod._bbsDeserializeSecretKey)
  mod.bbsSerializeSecretKey = _wrapSerialize(mod._bbsSerializeSecretKey)
  mod.bbsDeserializePublicKey = _wrapDeserialize(mod._bbsDeserializePublicKey)
  mod.bbsSerializePublicKey = _wrapSerialize(mod._bbsSerializePublicKey)
  mod.bbsDeserializeSignature = _wrapDeserialize(mod._bbsDeserializeSignature)
  mod.bbsSerializeSignature = _wrapSerialize(mod._bbsSerializeSignature)
  mod.bbsDeserializeProof = _wrapDeserialize(mod._bbsDeserializeProof)
  mod.bbsSerializeProof = _wrapSerialize(mod._bbsSerializeProof)
}

export const _showDebug = () => {
  if (mod.debug) {
    console.log('malloc DEBUG mode')
    console.log(`  show total=${mod.g_total}`)
    console.log(`  g_ptr=${JSON.stringify(mod.g_ptr, null, '\t')}`)
  }
}

export const init = async (): Promise<void> => {
  mod = await createModule({
    cryptoGetRandomValues: (p: number, n: number) => {
      const a = new Uint8Array(n)
      getRandomValues(a)
      for (let i = 0; i < n; i++) {
        mod.HEAP8[p + i] = a[i]
      }
    }
  })

  addWrappedMethods()

  const r: boolean = mod._bbsInit(128)
  if (!r) throw new Error(`_bbsInit err`)
}

abstract class Common {
  /** @internal */
  public a_: Uint32Array

  constructor (size: number) {
    this.a_ = new Uint32Array(size / 4)
  }

  deserializeHexStr (s: string): void {
    this.deserialize(fromHexStr(s))
  }

  serializeToHexStr (): string {
    return toHexStr(this.serialize())
  }

  dump (msg = ''): void {
    console.log(msg + this.serializeToHexStr())
  }

  clear (): void {
    this.a_.fill(0)
  }

  // copy to allocated memory
  copyToMem (pos: number): void {
    mod.HEAP32.set(this.a_, pos / 4)
  }

  // copy from allocated memory
  copyFromMem (pos: number): void {
    this.a_.set(mod.HEAP32.subarray(pos / 4, pos / 4 + this.a_.length))
  }

  abstract isEqual (rhs: this): boolean
  abstract deserialize (v: Uint8Array): void
  abstract serialize (): Uint8Array

  // internal methods

  /** @internal alloc new array */
  _alloc (): number {
    return mod._malloc(this.a_.length * 4)
  }

  /** @internal stack alloc new array */
  _salloc (): number {
    return mod.stackAlloc(this.a_.length * 4)
  }

  /** @internal alloc and copy a_ to mod.HEAP32[pos / 4] */
  _allocAndCopy (): number {
    const pos = this._alloc()
    mod.HEAP32.set(this.a_, pos / 4)
    return pos
  }

  /** @internal stack alloc and copy a_ to mod.HEAP32[pos / 4] */
  _sallocAndCopy (): number {
    const pos = this._salloc()
    mod.HEAP32.set(this.a_, pos / 4)
    return pos
  }

  /** @internal save pos to a_ */
  _save (pos: number): void {
    this.a_.set(mod.HEAP32.subarray(pos / 4, pos / 4 + this.a_.length))
  }

  /** @internal save and free */
  _saveAndFree (pos: number): void {
    this._save(pos)
    mod._free(pos)
  }

  /** @internal */
  _isEqual (func: (xPos: number, yPos: number) => number, rhs: Common): boolean {
    const stack = mod.stackSave()
    const xPos = this._sallocAndCopy()
    const yPos = rhs._sallocAndCopy()
    const r = func(xPos, yPos)
    mod.stackRestore(stack)
    return r === 1
  }
  /** @internal set parameter */
  _setter (func: Function, ...params: any[]): void {
    const stack = mod.stackSave()
    const pos = this._salloc()
    const r = func(pos, ...params)
    this._save(pos)
    mod.stackRestore(stack)
    if (r !== undefined && r !== 0) throw new Error('_setter err')
  }

  /** @internal getter */
  _getter (func: Function, ...params: any[]): any {
    const stack = mod.stackSave()
    const pos = this._sallocAndCopy()
    const s = func(pos, ...params)
    mod.stackRestore(stack)
    return s
  }

  /** @internal devide Uint32Array a into n and chose the idx-th */
  _getSubArray (idx: number, n: number): Uint32Array {
    const d = this.a_.length / n
    // return new Uint32Array(this.a_.buffer, d * idx * 4, d) // err : return reference to the buffer
    // correct : make new buffer and copy it
    return new Uint32Array(new Uint32Array(this.a_.buffer, d * idx * 4, d))
  }

  /** @internal set array lhs to idx */
  _setSubArray (lhs: Common, idx: number, n: number): void {
    const d = this.a_.length / n
    this.a_.set(lhs.a_, d * idx)
  }
}

interface HasArray {
  a_: Uint32Array;
}

const _cloneArray = <T extends HasArray> (x: T): T=> {
  const cstr = x.constructor as new () => T
  const r = new cstr()
  r.a_.set(x.a_)
  return r
}

export class SecretKey extends Common {
  constructor () {
    super(BBS_SECRETKEY_SIZE)
  }

  deserialize (s: Uint8Array): void {
    this._setter(mod.bbsDeserializeSecretKey, s)
  }

  serialize (): Uint8Array {
    return this._getter(mod.bbsSerializeSecretKey)
  }
  isEqual (rhs: this): boolean {
    return this._isEqual(mod._bbsIsEqualSecretKey, rhs)
  }

  clone (): SecretKey { return _cloneArray<SecretKey>(this) }

  /*
  init (): void {
    const stack = mod.stackSave()
    const pos = this._salloc()
    const r = mod._bbsInitSecretKey(pos)
    this._save(pos)
    mod.stackRestore(stack)
    if (!r) throw new Error('SecretKey::init error')
  }
  */

  init (): void {
    const a = new Uint8Array(BBS_SECRETKEY_SIZE)
    getRandomValues(a)
    console.log(`a=${toHexStr(a)}`)
    this._setter(mod.mclBnFr_setLittleEndianMod, a)
  }

  getPublicKey (): PublicKey {
    const pub = new PublicKey()
    const stack = mod.stackSave()
    const secPos = this._sallocAndCopy()
    const pubPos = this._salloc()
    const r = mod._bbsGetPublicKey(pubPos, secPos)
    pub._save(pubPos)
    mod.stackRestore(stack)
    if (!r) throw new Error('SecretKey::getPublicKey error')
    return pub
  }
}

export const deserializeHexStrToSecretKey = (s: string): SecretKey => {
  const r = new SecretKey()
  r.deserializeHexStr(s)
  return r
}

export class PublicKey extends Common {
  constructor () {
    super(BBS_PUBLICKEY_SIZE)
  }

  deserialize (s: Uint8Array): void {
    this._setter(mod.bbsDeserializePublicKey, s)
  }

  serialize (): Uint8Array {
    return this._getter(mod.bbsSerializePublicKey)
  }
  isEqual (rhs: this): boolean {
    return this._isEqual(mod._bbsIsEqualPublicKey, rhs)
  }

  clone (): PublicKey { return _cloneArray<PublicKey>(this) }
}

export const deserializeHexStrToPublicKey = (s: string): PublicKey => {
  const r = new PublicKey()
  r.deserializeHexStr(s)
  return r
}

export class Signature extends Common {
  constructor () {
    super(BBS_SIGNATURE_SIZE)
  }

  deserialize (s: Uint8Array): void {
    this._setter(mod.bbsDeserializeSignature, s)
  }

  serialize (): Uint8Array {
    return this._getter(mod.bbsSerializeSignature)
  }
  isEqual (rhs: this): boolean {
    return this._isEqual(mod._bbsIsEqualSignature, rhs)
  }

  clone (): Signature { return _cloneArray<Signature>(this) }
}

export const deserializeHexStrToSignature = (s: string): Signature => {
  const r = new Signature()
  r.deserializeHexStr(s)
  return r
}

const getTotalSizeOfMsgs = (msgs: Uint8Array[]): number => {
  return msgs.reduce((acc, msg) => acc + msg.length, 0)
}

// concatinate msgs to mod.HEAP8[pos]
const concatinateMsgs = (pos: number, msgs: Uint8Array[]): void => {
  let offset = 0
  for (let i = 0; i < msgs.length; i++) {
    mod.HEAP8.set(msgs[i], pos + offset)
    offset += msgs[i].length
  }
}

// copy msgs[i].length to mod.HEAP32[pos/4 + i]
const copyMsgSize = (pos: number, msgs: Uint8Array[]): void => {
  for (let i = 0; i < msgs.length; i++) {
    mod.HEAP32[(pos >> 2) + i] = msgs[i].length
  }
}

export const sign = (sec: SecretKey, pub: PublicKey, msgs: Uint8Array[]): Signature => {
  const msgN = msgs.length
  const totalMsgSize = getTotalSizeOfMsgs(msgs)

  const sig = new Signature()
  const stack = mod.stackSave()
  const sigPos = sig._salloc()
  const secPos = sec._sallocAndCopy()
  const pubPos = pub._sallocAndCopy()
  const msgsPos = mod.stackAlloc(totalMsgSize)
  const msgSizePos = mod.stackAlloc(msgN * 4)
  concatinateMsgs(msgsPos, msgs)
  copyMsgSize(msgSizePos, msgs)

  const r = mod._bbsSign(sigPos, secPos, pubPos, msgsPos, msgSizePos, msgN)
  sig._save(sigPos)
  mod.stackRestore(stack)
  if (!r) throw new Error('SecretKey::sign error')
  return sig
}

export const verify = (sig: Signature, pub: PublicKey, msgs: Uint8Array[]): boolean => {
  const msgN = msgs.length
  const totalMsgSize = getTotalSizeOfMsgs(msgs)

  const stack = mod.stackSave()
  const sigPos = sig._sallocAndCopy()
  const pubPos = pub._sallocAndCopy()
  const msgsPos = mod.stackAlloc(totalMsgSize)
  const msgSizePos = mod.stackAlloc(msgN * 4)
  concatinateMsgs(msgsPos, msgs)
  copyMsgSize(msgSizePos, msgs)

  const r = mod._bbsVerify(sigPos, pubPos, msgsPos, msgSizePos, msgN)
  mod.stackRestore(stack)
  return r
}

export class Proof {
  pos: number
  constructor () {
    this.pos = 0
  }

  deserialize (s: Uint8Array): Proof {
    const r = new Proof()
    const size = s.length
    const stack = mod.stackSave()
    const pos = mod.stackAlloc(size)
    mod.HEAP8.set(s, pos)
    r.pos = mod._bbsDeserializeProof(pos, size)
    mod.stackRestore(stack)
    if (r.pos === 0) throw new Error('Proof::deserialize error')
    return r
  }

  serialize (): Uint8Array {
    const size = mod.bbsGetProofSerializeByteSize(this.pos)
    const stack = mod.stackSave()
    const pos = mod._salloc(size)
    mod._bbsSerializeProof(pos, size, this.pos)
    const a = new Uint8Array(mod.HEAD8.subarray(pos, pos + size))
    mod.stackRestore(stack)
    return a
  }
}

export const createProof = (pub: PublicKey, sig: Signature, msgs: Uint8Array[], discIdxs: Uint32Array, nonce?: Uint8Array): Proof => {
  const msgN = msgs.length
  const totalMsgSize = getTotalSizeOfMsgs(msgs)
  const discN = discIdxs.length
  const r = new Proof()
  const stack = mod.stackSave()
  const pubPos = pub._sallocAndCopy()
  const sigPos = sig._sallocAndCopy()
  const msgsPos = mod.stackAlloc(totalMsgSize)
  const msgSizePos = mod.stackAlloc(msgN * 4)
  const discIdxsPos = mod.stackAlloc(discN * 4)
  concatinateMsgs(msgsPos, msgs)
  copyMsgSize(msgSizePos, msgs)
  mod.HEAP32.set(discIdxs, discIdxsPos / 4)
  let noncePos = 0
  let nonceLen = 0
  if (nonce !== null && nonce !== undefined) {
    noncePos = mod.stackAlloc(nonce.length)
    mod.HEAP8.set(nonce, noncePos)
    nonceLen = nonce.length
  }
  r.pos = mod._bbsCreateProof(pubPos, sigPos, msgsPos, msgSizePos, msgN, discIdxsPos, discN, noncePos, nonceLen)

  mod.stackRestore(stack)
  if (r.pos === 0) throw new Error('Proof::createProof error')
  return r
}

export const destroyProof = (prf: Proof): void => {
  mod._bbsDestroyProof(prf.pos)
}

// discMsgs[i] = msgs[discIdxs[i]]
export const verifyProof = (pub: PublicKey, prf: Proof, discMsgs: Uint8Array[], discIdxs: Uint32Array, nonce?: Uint8Array): boolean => {
  const discN = discMsgs.length
  if (discN !== discIdxs.length) throw new Error(`verifyProof:bad size. discMsgs.length=${discN} !== discIdxs.length=${discIdxs.length}`)
  const totalDiscMsgSize = getTotalSizeOfMsgs(discMsgs)

  const stack = mod.stackSave()
  const pubPos = pub._sallocAndCopy()
  const discMsgPos = mod.stackAlloc(totalDiscMsgSize)
  const discMsgSizePos = mod.stackAlloc(discN * 4)
  const discIdxsPos = mod.stackAlloc(discN * 4)
  concatinateMsgs(discMsgPos, discMsgs)
  copyMsgSize(discMsgSizePos, discMsgs)
  mod.HEAP32.set(discIdxs, discIdxsPos / 4)
  let noncePos = 0
  let nonceLen = 0
  if (nonce !== null && nonce !== undefined) {
    noncePos = mod.stackAlloc(nonce.length)
    mod.HEAP8.set(nonce, noncePos)
    nonceLen = nonce.length
  }
  const r = mod._bbsVerifyProof(pubPos, prf.pos, discMsgPos, discMsgSizePos, discIdxsPos, discN, noncePos, nonceLen)
  mod.stackRestore(stack)
  return r === 1
}
